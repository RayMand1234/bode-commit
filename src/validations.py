import json
import os

import dotenv
import gitlab.exceptions
import gitlab.v4
import gitlab.v4.objects
import openai
import myLogger
import re
import pathspec

CONVENTIONAL_COMMIT_TYPES = {
    "feat", "fix", "chore", "docs", "style", "hotfix",
    "refactor", "perf", "test", "build", "ci", "revert"
}


dotenv.load_dotenv()
client = openai.OpenAI(base_url="https://api.groq.com/openai/v1", api_key=os.getenv("GROQ_API_KEY"))


def validate_commits_range(commits, min_commits=1, max_commits=40):
    myLogger.logger.info(f"Validating commit volume: {min_commits} to {max_commits}")
    filtered_commits = list(filter(
        lambda commit: (not commit.title.lower().startswith(('fix', 'hotfix', 'docs', 'merge', 'initial commit'))),
        commits))

    result = len(filtered_commits) in range(min_commits, max_commits + 1)
    myLogger.logger.info(f"Commit volume: {len(filtered_commits)}/{len(commits)} commits valid")

    return result


def is_conventional_commit(message: str) -> bool:
    """
    Validates a commit message against the Conventional Commits standard.
    Ignores unnecessary spaces.
    """
    # Normalize message by stripping and collapsing spaces
    normalized = re.sub(r'\s+', ' ', message.strip())

    # Regex with optional spacing around type/scope/colon
    pattern = r'^\s*(\w+)\s*(\(\s*[^()]+\s*\))?\s*:\s*(.+)$'
    match = re.match(pattern, normalized)

    if not match:
        return False

    commit_type = match.group(1).strip()
    return commit_type.lower() in CONVENTIONAL_COMMIT_TYPES


def validate_commits_standard(commits):
    myLogger.logger.info("Analyzing commit standards")

    # filteres commits based on standard commit convention and maps to commit titles.
    valid_commits = list(filter(
        lambda commit: (is_conventional_commit(commit.title) or
                        commit.title.lower().startswith(('merge branch', 'initial commit'))), commits))
    valid_count = len(valid_commits)

    print("Non standard commits:")

    for commit in commits:
        if commit not in valid_commits:
            print(commit.title)

    total_commits = len(commits)
    ratio = valid_count / total_commits if total_commits > 0 else 0

    return {
        "validationStatus": get_commit_status(ratio),
        "valid_commits": valid_count,
        "total_commits": total_commits,
        "ratio": ratio
    }


def get_commit_status(ratio):
    if ratio >= 0.95:
        return 'excellent'
    elif ratio >= 0.80:
        return 'good'
    elif ratio >= 0.50:
        return 'passed'

    return 'failed'


def validate_significant_commits(commits):
    commits_formatted = ""
    for commit in commits:
        commits_formatted += commit.title + "\n"

    myLogger.logger.info("Analyzing commit significance")
    prompt = f"""
    Return raw JSON only. Do not wrap in triple backticks or any markdown.:
    {{
      "validationStatus": "passed" | "failed"
      "info": [
        {{
          "commit": "<full commit message>",
          "result": "passed" | "failed - <reason>"
        }},
        ...
      ]
    }}

    You are an expert reviewer of Git commit messages.

    Your job is to check if a commit message is **good enough** for practical team use.

    A commit message is ✅ Valid if:

    1. It is structured or recognizable — like Conventional Commits (e.g., `feat(scope): description`), or even common phrases like "Initial commit".
    2. It includes **basic context or purpose** — e.g., “added alerts”, “refactored UI logic”, “initial project”.
    3. It avoids **unhelpful** messages like “stuff”, “final version”, “more fixes”, or “commit after day one”.
    4. Don't pay attention to typos.
    5. Treat default commits messages generated by gitlab like: "Merge branch" and "initial commit" as a valid and significant commit message
    
    You should be **lenient but intelligent** — the goal is to accept messages that help teammates understand the change **at a glance**, not to enforce excessive detail.

    ---

    Examples:

    ✅ Valid:
    - `feat(many): added alerts`
    - `refactor(many): changed the code and did some styling`
    - `feat(many): added loading pages and some styling`
    - `feat(many): added API with hook for locations`
    - `feat(many): added weather card component`
    - `Initial commit`

    ❌ Invalid:
    - `fix`
    - `changes`
    - `stuff`
    - `more commits`
    - `commit after day one`
    - `finalVersion`

    ---

    Input:
    {commits_formatted}

    Answer:"""

    response = client.chat.completions.create(
        model="meta-llama/llama-4-scout-17b-16e-instruct",
        messages=[{"role": "user", "content": prompt}],
        temperature=0
    )

    content = response.to_dict().get('choices')[0]['message']['content']
    result = json.loads(content)

    for commit in result['info']:
        if commit['result'].startswith('failed'):
            print(commit)

    return result


def validate_gitignore(project, ref_branch):
    myLogger.logger.info("Analyzing gitignore existence")

    items = project.repository_tree(path="", ref=ref_branch, recursive=True, all=True)
    filenames = list(map(lambda item: (item['name']), items))

    with open('./gitignore_rules/default.gitignore', 'r') as f:
        spec = pathspec.GitIgnoreSpec.from_lines(f)

    ignored_files = list(spec.match_files(filenames))

    if len(ignored_files) > 0:
        myLogger.logger.info(f'FOUND NON IGNORED FILES: {ignored_files}')
        return False

    return ".gitignore" in filenames


def validate_succinct_commits(commits):
    VALID_UNSUCCINCT_PERCENTAGE = 0.25
    MAX_CHARS = 60

    myLogger.logger.info("Analyzing succinct commits")
    # Filter commits based on commit description after the colon
    unsuccinct_commits = list(
        filter(lambda commit: (":" in commit.title and len(commit.title.partition(":")[2]) > MAX_CHARS), commits))

    return len(unsuccinct_commits) < VALID_UNSUCCINCT_PERCENTAGE * len(commits)


def validate_main_latest_version(project: gitlab.v4.objects.Project):
    latets_mrs = project.mergerequests.list(order_by='updated_at', sort='desc', per_page=1)

    if len(latets_mrs) == 0:
        return False

    return latets_mrs[0].state == 'merged'
